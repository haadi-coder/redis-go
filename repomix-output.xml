This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.codecrafters/
  compile.sh
  run.sh
app/
  cache.go
  main.go
.gitattributes
codecrafters.yml
go.mod
README.md
your_program.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".codecrafters/compile.sh">
#!/bin/sh
#
# This script is used to compile your program on CodeCrafters
#
# This runs before .codecrafters/run.sh
#
# Learn more: https://codecrafters.io/program-interface

set -e # Exit on failure

go build -o /tmp/codecrafters-build-redis-go app/*.go
</file>

<file path=".codecrafters/run.sh">
#!/bin/sh
#
# This script is used to run your program on CodeCrafters
#
# This runs after .codecrafters/compile.sh
#
# Learn more: https://codecrafters.io/program-interface

set -e # Exit on failure

exec /tmp/codecrafters-build-redis-go "$@"
</file>

<file path=".gitattributes">
* text=auto
</file>

<file path="go.mod">
module github.com/codecrafters-io/redis-starter-go

go 1.24.0
</file>

<file path="README.md">
[![progress-banner](https://backend.codecrafters.io/progress/redis/e98a3efa-4c1a-4e55-8e57-46ab3c15b974)](https://app.codecrafters.io/users/codecrafters-bot?r=2qF)

This is a starting point for Go solutions to the
["Build Your Own Redis" Challenge](https://codecrafters.io/challenges/redis).

In this challenge, you'll build a toy Redis clone that's capable of handling
basic commands like `PING`, `SET` and `GET`. Along the way we'll learn about
event loops, the Redis protocol and more.

**Note**: If you're viewing this repo on GitHub, head over to
[codecrafters.io](https://codecrafters.io) to try the challenge.

# Passing the first stage

The entry point for your Redis implementation is in `app/main.go`. Study and
uncomment the relevant code, and push your changes to pass the first stage:

```sh
git commit -am "pass 1st stage" # any msg
git push origin master
```

That's all!

# Stage 2 & beyond

Note: This section is for stages 2 and beyond.

1. Ensure you have `go (1.24)` installed locally
1. Run `./your_program.sh` to run your Redis server, which is implemented in
   `app/main.go`.
1. Commit your changes and run `git push origin master` to submit your solution
   to CodeCrafters. Test output will be streamed to your terminal.
</file>

<file path="your_program.sh">
#!/bin/sh
#
# Use this script to run your program LOCALLY.
#
# Note: Changing this script WILL NOT affect how CodeCrafters runs your program.
#
# Learn more: https://codecrafters.io/program-interface

set -e # Exit early if any commands fail

# Copied from .codecrafters/compile.sh
#
# - Edit this to change how your program compiles locally
# - Edit .codecrafters/compile.sh to change how your program compiles remotely
(
  cd "$(dirname "$0")" # Ensure compile steps are run within the repository directory
  go build -o /tmp/codecrafters-build-redis-go app/*.go
)

# Copied from .codecrafters/run.sh
#
# - Edit this to change how your program runs locally
# - Edit .codecrafters/run.sh to change how your program runs remotely
exec /tmp/codecrafters-build-redis-go "$@"
</file>

<file path="codecrafters.yml">
# Set this to true if you want debug logs.
#
# These can be VERY verbose, so we suggest turning them off
# unless you really need them.
debug: true

# Use this to change the Go version used to run your code
# on Codecrafters.
#
# Available versions: go-1.24
language_pack: go-1.24
</file>

<file path="app/cache.go">
package main

import (
	"sync"
	"time"
)

type cache struct {
	data map[string]item
	mu   sync.RWMutex
}

type item struct {
	value  string
	expiry time.Time
}

func newCache() *cache {
	c := &cache{
		data: make(map[string]item),
	}

	go func() {
		for range time.Tick(2 * time.Second) {
			c.mu.Lock()

			for key, item := range c.data {
				if item.isExpired() {
					delete(c.data, key)
				}
			}

			c.mu.Unlock()
		}
	}()

	return c
}

func (c *cache) get(key string) (string, bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	item, found := c.data[key]

	if item.isExpired() {
		delete(c.data, key)
		return item.value, false
	}

	return item.value, found
}

func (c *cache) set(key string, value string, ttl time.Duration) {
	c.mu.Lock()
	defer c.mu.Unlock()

	expiry := time.Time{}
	if ttl > 0 {
		expiry = time.Now().Add(ttl)
	}

	c.data[key] = item{
		value:  value,
		expiry: expiry,
	}
}

func (i *item) isExpired() bool {
	return !i.expiry.IsZero() && time.Now().After(i.expiry)
}
</file>

<file path="app/main.go">
package main

import (
	"bufio"
	"fmt"
	"io"
	"net"
	"os"
	"strconv"
	"strings"
	"time"
)

const (
	Array  = '*'
	Simple = '+'
	Bulk   = '$'
)

func main() {
	fmt.Println("Logs from your program will appear here!")

	if err := run(); err != nil {
		fmt.Print(err)
		os.Exit(1)
	}
}

func run() error {
	cache := newCache()

	l, err := net.Listen("tcp", "0.0.0.0:6379")
	if err != nil {
		return fmt.Errorf("failed to bind to port 6379: %w", err)
	}

	defer func() {
		_ = l.Close()
	}()

	for {
		conn, err := l.Accept()
		if err != nil {
			return fmt.Errorf("failed to accept connection: %w", err)
		}

		go func() {
			err = handleConn(conn, cache)
		}()

		if err != nil {
			return fmt.Errorf("failed to handle connection: %w", err)
		}
	}
}

func handleConn(conn net.Conn, cache *cache) error {
	defer func() {
		_ = conn.Close()
	}()

	reader := bufio.NewReader(conn)

	for {
		resp, err := parseResp(reader)
		if err != nil {
			return fmt.Errorf("failed to parse RESP: %w", err)
		}

		if len(resp.Value) == 0 {
			continue
		}

		command := strings.ToUpper(resp.Value[0])

		switch command {
		case "PING":
			_, _ = conn.Write([]byte("+PONG\r\n"))
		case "ECHO":
			if len(resp.Value) < 2 {
				_, _ = conn.Write([]byte("$-1\r\n"))
			} else {
				_, _ = conn.Write(toBulk(resp.Value[1]))
			}
		case "GET":
			value, found := cache.get(resp.Value[1])
			if !found {
				_, _ = conn.Write([]byte("$-1\r\n"))
			} else {
				_, _ = conn.Write(toBulk(value))
			}
		case "SET":
			var ttl time.Duration
			if len(resp.Value) > 3 {
				if strings.ToUpper(resp.Value[3]) == "PX" {
					wait, _ := strconv.Atoi(resp.Value[4])
					ttl = time.Duration(wait) * time.Millisecond
				}
			}

			cache.set(resp.Value[1], resp.Value[2], ttl)
			_, _ = conn.Write([]byte("+OK\r\n"))

		default:
			return fmt.Errorf("unknown command: %s", command)
		}
	}
}

type Resp struct {
	Type  string
	Value []string
}

func parseResp(reader *bufio.Reader) (*Resp, error) {
	line, err := reader.ReadString('\n')
	if err != nil {
		return nil, fmt.Errorf("failed to read first line")
	}

	trimmed := strings.TrimSpace(line)

	if len(trimmed) == 0 {
		return nil, fmt.Errorf("empty trimmed")
	}

	switch trimmed[0] {
	case Array:
		return fromArray(trimmed, reader)
	case Bulk:
		return fromBulk(trimmed, reader)
	case Simple:
		return &Resp{
			Type:  "simple",
			Value: []string{trimmed[1:]},
		}, nil
	default:
		return nil, fmt.Errorf("unsupported RESP type: %c", trimmed[0])
	}
}

func fromArray(line string, reader *bufio.Reader) (*Resp, error) {
	var count int
	_, err := fmt.Sscanf(line, "*%d\r\n", &count)
	if err != nil {
		return nil, fmt.Errorf("failed to scan array length: %w", err)
	}

	var parts = make([]string, count)
	for i := range count {
		line, err := reader.ReadString('\n')
		if err != nil {
			return nil, fmt.Errorf("failed to read bulk")
		}

		var length int
		_, err = fmt.Sscanf(line, "$%d\r\n", &length)
		if err != nil {
			return nil, fmt.Errorf("failed to scan bulk length")
		}

		value := make([]byte, length)
		_, err = io.ReadFull(reader, value)
		if err != nil {
			return nil, fmt.Errorf("failed to read bulk data")
		}

		_, err = reader.ReadString('\n')
		if err != nil {
			return nil, fmt.Errorf("failed to read final CRLF")
		}

		parts[i] = string(value)
	}

	return &Resp{
		Type:  "array",
		Value: parts,
	}, nil
}

func fromBulk(line string, reader *bufio.Reader) (*Resp, error) {
	var length int
	_, err := fmt.Sscanf(line, "$%d", &length)
	if err != nil {
		return nil, fmt.Errorf("failed to scan bulk size: %w", err)
	}

	value := make([]byte, length)
	_, err = io.ReadFull(reader, value)
	if err != nil {
		return nil, fmt.Errorf("failed to read bulk data: %w", err)
	}

	_, err = reader.ReadString('\n')
	if err != nil {
		return nil, fmt.Errorf("failed to read CRLF after bulk: %w", err)
	}

	return &Resp{
		Type:  "bulk",
		Value: []string{string(value)},
	}, nil
}

func toBulk(str string) []byte {
	bytes := len(str)
	bulk := fmt.Sprintf("$%d\r\n%s\r\n", bytes, str)

	return []byte(bulk)
}
</file>

</files>
